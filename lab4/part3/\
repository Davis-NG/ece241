`timescale 1ns / 1ns // `timescale time_unit/time_precision

module part3(clock, reset, ParallelLoadn, RotateRight, ASRight, Data_IN, Q);
    input clock, reset, ParallelLoadn, RotateRight, ASRight;
    input [7:0] Data_IN;
    output [7:0] Q;
    wire [7:0] w;
    wire shift; 

    assign Q = w;
    
    mux2to1 m0(.x(Q[0]), .y(Q[7]), .s(ASRight), .m(shift));

    sub_circuit s0(.left(w[7]), .right(w[1]), .LoadLeft(RotateRight), .D(Data_IN[0]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[0]));
    sub_circuit s1(.left(w[0]), .right(w[2]), .LoadLeft(RotateRight), .D(Data_IN[1]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[1]));
    sub_circuit s2(.left(w[1]), .right(w[3]), .LoadLeft(RotateRight), .D(Data_IN[2]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[2]));
    sub_circuit s3(.left(w[2]), .right(w[4]), .LoadLeft(RotateRight), .D(Data_IN[3]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[3]));
    sub_circuit s4(.left(w[3]), .right(w[5]), .LoadLeft(RotateRight), .D(Data_IN[4]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[4]));
    sub_circuit s5(.left(w[4]), .right(w[6]), .LoadLeft(RotateRight), .D(Data_IN[5]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[5]));
    sub_circuit s6(.left(w[5]), .right(w[7]), .LoadLeft(RotateRight), .D(Data_IN[6]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[6]));
    sub_circuit s7(.left(w[6]), .right(shift), .LoadLeft(RotateRight), .D(Data_IN[7]), .loadn(ParallelLoadn), .clock(clock), .reset(reset), .Q(w[7]));
endmodule

module TopG(SW, KEY, LEDR);
    input [9:0] SW;
    input [3:0] KEY;
    output [7:0] LEDR;

    part3 u0(.clock(KEY[0]), .reset(SW[9]), .ParallelLoadn(KEY[1]), .RotateRight(KEY[2]), .ASRight(KEY[3]), .Data_IN(SW[7:0]), .Q(LEDR[7:0]));
endmodule

module sub_circuit(right, left, LoadLeft, D, loadn, clock, reset, Q);
    input right, left, LoadLeft, loadn, D, clock, reset;
    output Q; 
    wire w1, w2;

    mux2to1 M0(.x(right), .y(left), .s(LoadLeft), .m(w1)); // in loving memory of Mo Wang
    mux2to1 M1(.x(D), .y(w1), .s(loadn), .m(w2));
    
    flipFlop F0(.Clock(clock), .Reset(reset), .d(w2), .q(Q));
endmodule

module mux2to1(x, y, s, m);
    input x; //select 0
    input y; //select 1
    input s; //select signal
    output m; //output
  
    //assign m = s & y | ~s & x;
    // OR
    assign m = s ? y : x;
endmodule

module flipFlop(Clock, Reset, d, q);
    input Clock, Reset, d;
    output reg q;

    always @(posedge Clock) // triggered every time clock rises
    begin
        if (Reset == 1'b1) // when Reset_b is 0 (tested on every rising clock edge)
            q <= 0;         // q is set to when Reset_b is not zero
        else 
            q <= d;         // value of d passes through to output q
    end
endmodule
